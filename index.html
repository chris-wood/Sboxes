<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Cryptographic S-box Code by chris-wood</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Cryptographic S-box Code</h1>
        <p></p>

        <p class="view"><a href="https://github.com/chris-wood/Sboxes">View the Project on GitHub <small>chris-wood/Sboxes</small></a></p>


        <ul>
          <li><a href="https://github.com/chris-wood/Sboxes/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/chris-wood/Sboxes/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/chris-wood/Sboxes">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Welcome!</h3>

<p>
In this section we provide a brief tutorial on how to use the ``toy'' Galois field composite arithmetic library. As a whole, it only supports basic arithmetic for $GF(p)$ and $GF(q^n)$, $q = p^m$. Even with this limitation, it can be quite useful for those trying to understand the mathematical concepts of composite fields and the corresponding arithmetic, as seemingly simple as it may be.
</p> 

<p>
Consider the field $GF(2^4)$ defined by the irreducible polynomial $p(x) = x^4 + x + 1$. Let $\alpha = x^3 + 1$ be an element in this field. We can create this Galois field element and perform arithmetic in the field $GF(2^4)$ as follows:
</p>

<pre><code>
>>> from galois import *
>>> ip = GFElem([1,0,0,1,1]) 
>>> F = GF(2, 4, ip)
>>> print(F)
GF(2^4), P(x) = (1x^4 + 1x^1 + 1x^0)
>>> x = GFElem([1,0,0,1])
>>> print(x)
(1x^3 + 1x^0)
>>> xa = F.g_add(x, x)
>>> print(xa)
0
>>> xs = F.g_mult(x, x)
>>> print(xs)
(1x^3 + 1x^2 + 1x^0)
>>> print(F.g_mult(F.inverse(x), x))
(1x^0)
</code></pre>

<p>
Creation of Galois field elements is as simple as providing a list of coefficients in the ground field. Also, even though the example works with binary fields only, the library can support any prime $p$ as the field characteristic. 
</p>

<p>
Now assume we wish to create the a degree-2 extension of this field, i.e. $GF((2^4)^2)$, using the irreducible polynomial $y^2 + y + (x^3 + x^2)$. Notice that the coefficients of each term are elements of the field $GF(2^4)$, as per our earlier definition. Let $\beta = (x^2 + 1)y + (x^2 + x + 1)$ be an element in $GF((2^4)^2)$. We can create this field and element to perform basic arithmetic as in the base field as follow.
</p>

<pre><code>
>>> eIp = GFExtensionElem([GFElem([1]), GFElem([1]), GFElem([1,1,0,0])]) 
>>> F2 = GFExtension(F, 2, eIp)
>>> print(F2)
2 degree extension of: GF(2^4)
>>> b = GFExtensionElem([GFElem([1,0,1]),GFElem([1,1,1])])
>>> print(b)
[(1x^2 + 1x^0)y^1 + (1x^2 + 1x^1 + 1x^0)y^0]
>>> ba = F2.g_add(b, b)
>>> print(ba)
0
>>> bs = F2.g_mult(b, b)
>>> print(bs)
[(1x^1)y^1 + (1x^3 + 1x^2 + 1x^0)y^0]
>>> bi = F2.power(b, 254) # Fermat's Little Theorem says this should be the inverse
>>> print(bi) 
[(1x^0)y^0]               # And so it is...
</code></pre>

<p>The reader is welcome to browse the library source code and play with additional features (e.g. finding generators for a field) at their own leisure.</p>

      </section>

      <section>
        
      <h3>S-Box Gate Counting</h3>

      <p>The Magma code snippet below was taken from my thesis document. Many custom functions for changing between polynomial and normal bases was written. The implementation of these functions can be found in the repository.</p>

<pre>
<code>
////////////////////////////////////////////////////////////
/////////////// START AES ALTERNATIVE SEARCH ///////////////
////////////////////////////////////////////////////////////
F:=GF(2);
polRing<V>:=PolynomialRing(F);
S := V^8 + V^4 + V^3 + V + 1; // fixed affine for AES polynomial
F256<x>:=ext<F | S>;
if PrimitiveElement(F256) ne x + 1 then
    quit;
end if;
affine:=Matrix(GF(2),8,8, // affine == M
            [
      [1,1,1,1,1,0,0,0],
      [0,1,1,1,1,1,0,0],
      [0,0,1,1,1,1,1,0],
      [0,0,0,1,1,1,1,1],
      [1,0,0,0,1,1,1,1],
      [1,1,0,0,0,1,1,1],
      [1,1,1,0,0,0,1,1],
      [1,1,1,1,0,0,0,1]
            ]);
constant := x^6 + x^5 + x + 1;
cinv := constantAffineInv(affine, constant, F256);
p := allGen_8(0, F256, S, affine, constant, cinv); 
////////////////////////////////////////////////////////////
///////////////  END AES ALTERNATIVE SEARCH  ///////////////
////////////////////////////////////////////////////////////
</code>
</pre>

<pre>
<code>
////////////////////////////////////////////////////////////
///////////////   START THESIS TEST CASE 1   ///////////////
////////////////////////////////////////////////////////////
F2 := GF(2);
Poly2<V> := PolynomialRing(F2);
P := V^2 + V + 1;
F4<v> := ext<F2 | P>;
Poly4<W> := PolynomialRing(F4);
Q := W^2 + W + v;
F16<w> := ext<F4 | Q>;
Poly16<X> := PolynomialRing(F16);
R := X^2 + X + (v + 1)*w + v;
F256<x> := ext<F16 | R>;
newSigma := changeSigmaRoot(1, v, F4, v);
newPi := changePiRoot(1, v, w, w^4, F4, F16, (v + 1)*w + v);
gatesInv8(P, Q, R, newSigma, newPi, 1, v, w, w^4, x, x^16);
////////////////////////////////////////////////////////////
///////////////    END THESIS TEST CASE 1    ///////////////
////////////////////////////////////////////////////////////
</pre>
</code>

<pre>
<code>
////////////////////////////////////////////////////////////
///////////////   START THESIS TEST CASE 2   ///////////////
////////////////////////////////////////////////////////////
F2 := GF(2);
Poly2<V> := PolynomialRing(F2);
P := V^2 + V + 1;
F4<v> := ext<F2 | P>;
Poly4<W> := PolynomialRing(F4);
Q := W^2 + W + v;
F16<w> := ext<F4 | Q>;
Poly16<X> := PolynomialRing(F16);
R := X^2 + X + ((v + 1)*w + v);
F256<x> := ext<F16 | R>;
Poly256<Y> := PolynomialRing(F256);
S := Y^2 + Y + (v*w + v)*x + w;
F6K<y> := ext<F256 | S>;
gatesInv16(P, Q, R, S, v, ((v + 1)*w + v), (v*w*x + (w + v)), 1, v, 1, w, 1, x, 1, y);
////////////////////////////////////////////////////////////
///////////////    END THESIS TEST CASE 2    ///////////////
////////////////////////////////////////////////////////////
</code>
</pre>

      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/chris-wood">chris-wood</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>